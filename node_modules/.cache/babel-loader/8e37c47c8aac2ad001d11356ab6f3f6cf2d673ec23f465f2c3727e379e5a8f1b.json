{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n// --------- HELPERS\nfunction getElementOffset(el) {\n  let top = 0;\n  let left = 0;\n  let element = el;\n  // Loop through the DOM tree\n  // and add it's parent's offset to get page offset\n  do {\n    top += element.offsetTop || 0;\n    left += element.offsetLeft || 0;\n    element = element.offsetParent;\n  } while (element);\n  return {\n    top,\n    left\n  };\n}\n// --------- SCROLL INTERFACES\n// ScrollDomElement and ScrollWindow have identical interfaces\nclass ScrollDomElement {\n  constructor(element) {\n    this.element = element;\n  }\n  getHorizontalScroll() {\n    return this.element.scrollLeft;\n  }\n  getVerticalScroll() {\n    return this.element.scrollTop;\n  }\n  getMaxHorizontalScroll() {\n    return this.element.scrollWidth - this.element.clientWidth;\n  }\n  getMaxVerticalScroll() {\n    return this.element.scrollHeight - this.element.clientHeight;\n  }\n  getHorizontalElementScrollOffset(elementToScrollTo, elementToScroll) {\n    return getElementOffset(elementToScrollTo).left - getElementOffset(elementToScroll).left;\n  }\n  getVerticalElementScrollOffset(elementToScrollTo, elementToScroll) {\n    return getElementOffset(elementToScrollTo).top - getElementOffset(elementToScroll).top;\n  }\n  scrollTo(x, y) {\n    this.element.scrollLeft = x;\n    this.element.scrollTop = y;\n  }\n}\nclass ScrollWindow {\n  constructor() {\n    this.element = window;\n  }\n  getHorizontalScroll() {\n    return window.scrollX || document.documentElement.scrollLeft;\n  }\n  getVerticalScroll() {\n    return window.scrollY || document.documentElement.scrollTop;\n  }\n  getMaxHorizontalScroll() {\n    return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth) - window.innerWidth;\n  }\n  getMaxVerticalScroll() {\n    return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight;\n  }\n  getHorizontalElementScrollOffset(elementToScrollTo) {\n    const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n    return scrollLeft + elementToScrollTo.getBoundingClientRect().left;\n  }\n  getVerticalElementScrollOffset(elementToScrollTo) {\n    const scrollTop = window.scrollY || document.documentElement.scrollTop;\n    return scrollTop + elementToScrollTo.getBoundingClientRect().top;\n  }\n  scrollTo(x, y) {\n    window.scrollTo(x, y);\n  }\n}\nconst activeAnimations = {\n  elements: [],\n  cancelMethods: [],\n  add: (element, cancelAnimation) => {\n    activeAnimations.elements.push(element);\n    activeAnimations.cancelMethods.push(cancelAnimation);\n  },\n  remove: (element, shouldStop) => {\n    const index = activeAnimations.elements.indexOf(element);\n    if (index > -1) {\n      // Stop animation\n      if (shouldStop) {\n        activeAnimations.cancelMethods[index]();\n      }\n      // Remove it\n      activeAnimations.elements.splice(index, 1);\n      activeAnimations.cancelMethods.splice(index, 1);\n    }\n  }\n};\n// --------- CHECK IF CODE IS RUNNING IN A BROWSER\nconst WINDOW_EXISTS = typeof window !== 'undefined';\n// --------- ANIMATE SCROLL TO\nconst defaultOptions = {\n  cancelOnUserAction: true,\n  easing: t => --t * t * t + 1,\n  elementToScroll: WINDOW_EXISTS ? window : null,\n  horizontalOffset: 0,\n  maxDuration: 3000,\n  minDuration: 250,\n  speed: 500,\n  verticalOffset: 0\n};\nfunction animateScrollTo(numberOrCoordsOrElement) {\n  let userOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    // Check for server rendering\n    if (!WINDOW_EXISTS) {\n      // @ts-ignore\n      // If it still gets called on server, return Promise for API consistency\n      return new Promise(resolve => {\n        resolve(false); // Returning false on server\n      });\n    } else if (!window.Promise) {\n      throw \"Browser doesn't support Promises, and animated-scroll-to depends on it, please provide a polyfill.\";\n    }\n    let x;\n    let y;\n    let scrollToElement;\n    let options = Object.assign(Object.assign({}, defaultOptions), userOptions);\n    const isWindow = options.elementToScroll === window;\n    const isElement = !!options.elementToScroll.nodeName;\n    if (!isWindow && !isElement) {\n      throw 'Element to scroll needs to be either window or DOM element.';\n    }\n    // Check for \"scroll-behavior: smooth\" as it can break the animation\n    // https://github.com/Stanko/animated-scroll-to/issues/55\n    const scrollBehaviorElement = isWindow ? document.documentElement : options.elementToScroll;\n    const scrollBehavior = getComputedStyle(scrollBehaviorElement).getPropertyValue('scroll-behavior');\n    if (scrollBehavior === 'smooth') {\n      console.warn(`${scrollBehaviorElement.tagName} has \"scroll-behavior: smooth\" which can mess up with animated-scroll-to's animations`);\n    }\n    // Select the correct scrolling interface\n    const elementToScroll = isWindow ? new ScrollWindow() : new ScrollDomElement(options.elementToScroll);\n    if (numberOrCoordsOrElement instanceof Element) {\n      scrollToElement = numberOrCoordsOrElement;\n      // If \"elementToScroll\" is not a parent of \"scrollToElement\"\n      if (isElement && (!options.elementToScroll.contains(scrollToElement) || options.elementToScroll.isSameNode(scrollToElement))) {\n        throw 'options.elementToScroll has to be a parent of scrollToElement';\n      }\n      x = elementToScroll.getHorizontalElementScrollOffset(scrollToElement, options.elementToScroll);\n      y = elementToScroll.getVerticalElementScrollOffset(scrollToElement, options.elementToScroll);\n    } else if (typeof numberOrCoordsOrElement === 'number') {\n      x = elementToScroll.getHorizontalScroll();\n      y = numberOrCoordsOrElement;\n    } else if (Array.isArray(numberOrCoordsOrElement) && numberOrCoordsOrElement.length === 2) {\n      x = numberOrCoordsOrElement[0] === null ? elementToScroll.getHorizontalScroll() : numberOrCoordsOrElement[0];\n      y = numberOrCoordsOrElement[1] === null ? elementToScroll.getVerticalScroll() : numberOrCoordsOrElement[1];\n    } else {\n      // ERROR\n      throw 'Wrong function signature. Check documentation.\\n' + 'Available method signatures are:\\n' + '  animateScrollTo(y:number, options)\\n' + '  animateScrollTo([x:number | null, y:number | null], options)\\n' + '  animateScrollTo(scrollToElement:Element, options)';\n    }\n    // Add offsets\n    x += options.horizontalOffset;\n    y += options.verticalOffset;\n    // Horizontal scroll distance\n    const maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();\n    const initialHorizontalScroll = elementToScroll.getHorizontalScroll();\n    // If user specified scroll position is greater than maximum available scroll\n    if (x > maxHorizontalScroll) {\n      x = maxHorizontalScroll;\n    }\n    // Calculate distance to scroll\n    const horizontalDistanceToScroll = x - initialHorizontalScroll;\n    // Vertical scroll distance distance\n    const maxVerticalScroll = elementToScroll.getMaxVerticalScroll();\n    const initialVerticalScroll = elementToScroll.getVerticalScroll();\n    // If user specified scroll position is greater than maximum available scroll\n    if (y > maxVerticalScroll) {\n      y = maxVerticalScroll;\n    }\n    // Calculate distance to scroll\n    const verticalDistanceToScroll = y - initialVerticalScroll;\n    // Calculate duration of the scroll\n    const horizontalDuration = Math.abs(Math.round(horizontalDistanceToScroll / 1000 * options.speed));\n    const verticalDuration = Math.abs(Math.round(verticalDistanceToScroll / 1000 * options.speed));\n    let duration = horizontalDuration > verticalDuration ? horizontalDuration : verticalDuration;\n    // Set minimum and maximum duration\n    if (duration < options.minDuration) {\n      duration = options.minDuration;\n    } else if (duration > options.maxDuration) {\n      duration = options.maxDuration;\n    }\n    // @ts-ignore\n    return new Promise((resolve, reject) => {\n      // Scroll is already in place, nothing to do\n      if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) {\n        // Resolve promise with a boolean hasScrolledToPosition set to true\n        resolve(true);\n      }\n      // Cancel existing animation if it is already running on the same element\n      activeAnimations.remove(elementToScroll.element, true);\n      // To cancel animation we have to store request animation frame ID\n      let requestID;\n      // Cancel animation handler\n      const cancelAnimation = () => {\n        removeListeners();\n        cancelAnimationFrame(requestID);\n        // Resolve promise with a boolean hasScrolledToPosition set to false\n        resolve(false);\n      };\n      // Registering animation so it can be canceled if function\n      // gets called again on the same element\n      activeAnimations.add(elementToScroll.element, cancelAnimation);\n      // Prevent user actions handler\n      const preventDefaultHandler = e => e.preventDefault();\n      const handler = options.cancelOnUserAction ? cancelAnimation : preventDefaultHandler;\n      // If animation is not cancelable by the user, we can't use passive events\n      const eventOptions = options.cancelOnUserAction ? {\n        passive: true\n      } : {\n        passive: false\n      };\n      const events = ['wheel', 'touchstart', 'keydown', 'mousedown'];\n      // Function to remove listeners after animation is finished\n      const removeListeners = () => {\n        events.forEach(eventName => {\n          elementToScroll.element.removeEventListener(eventName, handler, eventOptions);\n        });\n      };\n      // Add listeners\n      events.forEach(eventName => {\n        elementToScroll.element.addEventListener(eventName, handler, eventOptions);\n      });\n      // Animation\n      const startingTime = Date.now();\n      const step = () => {\n        var timeDiff = Date.now() - startingTime;\n        var t = timeDiff / duration;\n        const horizontalScrollPosition = Math.round(initialHorizontalScroll + horizontalDistanceToScroll * options.easing(t));\n        const verticalScrollPosition = Math.round(initialVerticalScroll + verticalDistanceToScroll * options.easing(t));\n        if (timeDiff < duration && (horizontalScrollPosition !== x || verticalScrollPosition !== y)) {\n          // If scroll didn't reach desired position or time is not elapsed\n          // Scroll to a new position\n          elementToScroll.scrollTo(horizontalScrollPosition, verticalScrollPosition);\n          // And request a new step\n          requestID = requestAnimationFrame(step);\n        } else {\n          // If the time elapsed or we reached the desired offset\n          // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n          // Clear animation frame to be sure\n          elementToScroll.scrollTo(x, y);\n          cancelAnimationFrame(requestID);\n          // Remove listeners\n          removeListeners();\n          // Remove animation from the active animations coordinator\n          activeAnimations.remove(elementToScroll.element, false);\n          // Resolve promise with a boolean hasScrolledToPosition set to true\n          resolve(true);\n        }\n      };\n      // Start animating scroll\n      requestID = requestAnimationFrame(step);\n    });\n  });\n}\nexport default animateScrollTo;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","getElementOffset","el","top","left","element","offsetTop","offsetLeft","offsetParent","ScrollDomElement","constructor","getHorizontalScroll","scrollLeft","getVerticalScroll","scrollTop","getMaxHorizontalScroll","scrollWidth","clientWidth","getMaxVerticalScroll","scrollHeight","clientHeight","getHorizontalElementScrollOffset","elementToScrollTo","elementToScroll","getVerticalElementScrollOffset","scrollTo","x","y","ScrollWindow","window","scrollX","document","documentElement","scrollY","Math","max","body","offsetWidth","innerWidth","offsetHeight","innerHeight","getBoundingClientRect","activeAnimations","elements","cancelMethods","add","cancelAnimation","push","remove","shouldStop","index","indexOf","splice","WINDOW_EXISTS","defaultOptions","cancelOnUserAction","easing","t","horizontalOffset","maxDuration","minDuration","speed","verticalOffset","animateScrollTo","numberOrCoordsOrElement","userOptions","arguments","length","undefined","scrollToElement","options","Object","assign","isWindow","isElement","nodeName","scrollBehaviorElement","scrollBehavior","getComputedStyle","getPropertyValue","console","warn","tagName","Element","contains","isSameNode","Array","isArray","maxHorizontalScroll","initialHorizontalScroll","horizontalDistanceToScroll","maxVerticalScroll","initialVerticalScroll","verticalDistanceToScroll","horizontalDuration","abs","round","verticalDuration","duration","requestID","removeListeners","cancelAnimationFrame","preventDefaultHandler","preventDefault","handler","eventOptions","passive","events","forEach","eventName","removeEventListener","addEventListener","startingTime","Date","now","timeDiff","horizontalScrollPosition","verticalScrollPosition","requestAnimationFrame"],"sources":["/Users/maxhsu/Documents/GitHub/avg-service/node_modules/animated-scroll-to/dist/esm/index.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// --------- HELPERS\nfunction getElementOffset(el) {\n    let top = 0;\n    let left = 0;\n    let element = el;\n    // Loop through the DOM tree\n    // and add it's parent's offset to get page offset\n    do {\n        top += element.offsetTop || 0;\n        left += element.offsetLeft || 0;\n        element = element.offsetParent;\n    } while (element);\n    return {\n        top,\n        left,\n    };\n}\n// --------- SCROLL INTERFACES\n// ScrollDomElement and ScrollWindow have identical interfaces\nclass ScrollDomElement {\n    constructor(element) {\n        this.element = element;\n    }\n    getHorizontalScroll() {\n        return this.element.scrollLeft;\n    }\n    getVerticalScroll() {\n        return this.element.scrollTop;\n    }\n    getMaxHorizontalScroll() {\n        return this.element.scrollWidth - this.element.clientWidth;\n    }\n    getMaxVerticalScroll() {\n        return this.element.scrollHeight - this.element.clientHeight;\n    }\n    getHorizontalElementScrollOffset(elementToScrollTo, elementToScroll) {\n        return (getElementOffset(elementToScrollTo).left -\n            getElementOffset(elementToScroll).left);\n    }\n    getVerticalElementScrollOffset(elementToScrollTo, elementToScroll) {\n        return (getElementOffset(elementToScrollTo).top -\n            getElementOffset(elementToScroll).top);\n    }\n    scrollTo(x, y) {\n        this.element.scrollLeft = x;\n        this.element.scrollTop = y;\n    }\n}\nclass ScrollWindow {\n    constructor() {\n        this.element = window;\n    }\n    getHorizontalScroll() {\n        return window.scrollX || document.documentElement.scrollLeft;\n    }\n    getVerticalScroll() {\n        return window.scrollY || document.documentElement.scrollTop;\n    }\n    getMaxHorizontalScroll() {\n        return (Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth) - window.innerWidth);\n    }\n    getMaxVerticalScroll() {\n        return (Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight);\n    }\n    getHorizontalElementScrollOffset(elementToScrollTo) {\n        const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n        return scrollLeft + elementToScrollTo.getBoundingClientRect().left;\n    }\n    getVerticalElementScrollOffset(elementToScrollTo) {\n        const scrollTop = window.scrollY || document.documentElement.scrollTop;\n        return scrollTop + elementToScrollTo.getBoundingClientRect().top;\n    }\n    scrollTo(x, y) {\n        window.scrollTo(x, y);\n    }\n}\nconst activeAnimations = {\n    elements: [],\n    cancelMethods: [],\n    add: (element, cancelAnimation) => {\n        activeAnimations.elements.push(element);\n        activeAnimations.cancelMethods.push(cancelAnimation);\n    },\n    remove: (element, shouldStop) => {\n        const index = activeAnimations.elements.indexOf(element);\n        if (index > -1) {\n            // Stop animation\n            if (shouldStop) {\n                activeAnimations.cancelMethods[index]();\n            }\n            // Remove it\n            activeAnimations.elements.splice(index, 1);\n            activeAnimations.cancelMethods.splice(index, 1);\n        }\n    },\n};\n// --------- CHECK IF CODE IS RUNNING IN A BROWSER\nconst WINDOW_EXISTS = typeof window !== 'undefined';\n// --------- ANIMATE SCROLL TO\nconst defaultOptions = {\n    cancelOnUserAction: true,\n    easing: (t) => --t * t * t + 1,\n    elementToScroll: WINDOW_EXISTS ? window : null,\n    horizontalOffset: 0,\n    maxDuration: 3000,\n    minDuration: 250,\n    speed: 500,\n    verticalOffset: 0,\n};\nfunction animateScrollTo(numberOrCoordsOrElement, userOptions = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Check for server rendering\n        if (!WINDOW_EXISTS) {\n            // @ts-ignore\n            // If it still gets called on server, return Promise for API consistency\n            return new Promise((resolve) => {\n                resolve(false); // Returning false on server\n            });\n        }\n        else if (!window.Promise) {\n            throw \"Browser doesn't support Promises, and animated-scroll-to depends on it, please provide a polyfill.\";\n        }\n        let x;\n        let y;\n        let scrollToElement;\n        let options = Object.assign(Object.assign({}, defaultOptions), userOptions);\n        const isWindow = options.elementToScroll === window;\n        const isElement = !!options.elementToScroll.nodeName;\n        if (!isWindow && !isElement) {\n            throw 'Element to scroll needs to be either window or DOM element.';\n        }\n        // Check for \"scroll-behavior: smooth\" as it can break the animation\n        // https://github.com/Stanko/animated-scroll-to/issues/55\n        const scrollBehaviorElement = isWindow\n            ? document.documentElement\n            : options.elementToScroll;\n        const scrollBehavior = getComputedStyle(scrollBehaviorElement).getPropertyValue('scroll-behavior');\n        if (scrollBehavior === 'smooth') {\n            console.warn(`${scrollBehaviorElement.tagName} has \"scroll-behavior: smooth\" which can mess up with animated-scroll-to's animations`);\n        }\n        // Select the correct scrolling interface\n        const elementToScroll = isWindow\n            ? new ScrollWindow()\n            : new ScrollDomElement(options.elementToScroll);\n        if (numberOrCoordsOrElement instanceof Element) {\n            scrollToElement = numberOrCoordsOrElement;\n            // If \"elementToScroll\" is not a parent of \"scrollToElement\"\n            if (isElement &&\n                (!options.elementToScroll.contains(scrollToElement) ||\n                    options.elementToScroll.isSameNode(scrollToElement))) {\n                throw 'options.elementToScroll has to be a parent of scrollToElement';\n            }\n            x = elementToScroll.getHorizontalElementScrollOffset(scrollToElement, options.elementToScroll);\n            y = elementToScroll.getVerticalElementScrollOffset(scrollToElement, options.elementToScroll);\n        }\n        else if (typeof numberOrCoordsOrElement === 'number') {\n            x = elementToScroll.getHorizontalScroll();\n            y = numberOrCoordsOrElement;\n        }\n        else if (Array.isArray(numberOrCoordsOrElement) &&\n            numberOrCoordsOrElement.length === 2) {\n            x =\n                numberOrCoordsOrElement[0] === null\n                    ? elementToScroll.getHorizontalScroll()\n                    : numberOrCoordsOrElement[0];\n            y =\n                numberOrCoordsOrElement[1] === null\n                    ? elementToScroll.getVerticalScroll()\n                    : numberOrCoordsOrElement[1];\n        }\n        else {\n            // ERROR\n            throw ('Wrong function signature. Check documentation.\\n' +\n                'Available method signatures are:\\n' +\n                '  animateScrollTo(y:number, options)\\n' +\n                '  animateScrollTo([x:number | null, y:number | null], options)\\n' +\n                '  animateScrollTo(scrollToElement:Element, options)');\n        }\n        // Add offsets\n        x += options.horizontalOffset;\n        y += options.verticalOffset;\n        // Horizontal scroll distance\n        const maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();\n        const initialHorizontalScroll = elementToScroll.getHorizontalScroll();\n        // If user specified scroll position is greater than maximum available scroll\n        if (x > maxHorizontalScroll) {\n            x = maxHorizontalScroll;\n        }\n        // Calculate distance to scroll\n        const horizontalDistanceToScroll = x - initialHorizontalScroll;\n        // Vertical scroll distance distance\n        const maxVerticalScroll = elementToScroll.getMaxVerticalScroll();\n        const initialVerticalScroll = elementToScroll.getVerticalScroll();\n        // If user specified scroll position is greater than maximum available scroll\n        if (y > maxVerticalScroll) {\n            y = maxVerticalScroll;\n        }\n        // Calculate distance to scroll\n        const verticalDistanceToScroll = y - initialVerticalScroll;\n        // Calculate duration of the scroll\n        const horizontalDuration = Math.abs(Math.round((horizontalDistanceToScroll / 1000) * options.speed));\n        const verticalDuration = Math.abs(Math.round((verticalDistanceToScroll / 1000) * options.speed));\n        let duration = horizontalDuration > verticalDuration\n            ? horizontalDuration\n            : verticalDuration;\n        // Set minimum and maximum duration\n        if (duration < options.minDuration) {\n            duration = options.minDuration;\n        }\n        else if (duration > options.maxDuration) {\n            duration = options.maxDuration;\n        }\n        // @ts-ignore\n        return new Promise((resolve, reject) => {\n            // Scroll is already in place, nothing to do\n            if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) {\n                // Resolve promise with a boolean hasScrolledToPosition set to true\n                resolve(true);\n            }\n            // Cancel existing animation if it is already running on the same element\n            activeAnimations.remove(elementToScroll.element, true);\n            // To cancel animation we have to store request animation frame ID\n            let requestID;\n            // Cancel animation handler\n            const cancelAnimation = () => {\n                removeListeners();\n                cancelAnimationFrame(requestID);\n                // Resolve promise with a boolean hasScrolledToPosition set to false\n                resolve(false);\n            };\n            // Registering animation so it can be canceled if function\n            // gets called again on the same element\n            activeAnimations.add(elementToScroll.element, cancelAnimation);\n            // Prevent user actions handler\n            const preventDefaultHandler = (e) => e.preventDefault();\n            const handler = options.cancelOnUserAction\n                ? cancelAnimation\n                : preventDefaultHandler;\n            // If animation is not cancelable by the user, we can't use passive events\n            const eventOptions = options.cancelOnUserAction\n                ? { passive: true }\n                : { passive: false };\n            const events = ['wheel', 'touchstart', 'keydown', 'mousedown'];\n            // Function to remove listeners after animation is finished\n            const removeListeners = () => {\n                events.forEach((eventName) => {\n                    elementToScroll.element.removeEventListener(eventName, handler, eventOptions);\n                });\n            };\n            // Add listeners\n            events.forEach((eventName) => {\n                elementToScroll.element.addEventListener(eventName, handler, eventOptions);\n            });\n            // Animation\n            const startingTime = Date.now();\n            const step = () => {\n                var timeDiff = Date.now() - startingTime;\n                var t = timeDiff / duration;\n                const horizontalScrollPosition = Math.round(initialHorizontalScroll +\n                    horizontalDistanceToScroll * options.easing(t));\n                const verticalScrollPosition = Math.round(initialVerticalScroll + verticalDistanceToScroll * options.easing(t));\n                if (timeDiff < duration &&\n                    (horizontalScrollPosition !== x || verticalScrollPosition !== y)) {\n                    // If scroll didn't reach desired position or time is not elapsed\n                    // Scroll to a new position\n                    elementToScroll.scrollTo(horizontalScrollPosition, verticalScrollPosition);\n                    // And request a new step\n                    requestID = requestAnimationFrame(step);\n                }\n                else {\n                    // If the time elapsed or we reached the desired offset\n                    // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n                    // Clear animation frame to be sure\n                    elementToScroll.scrollTo(x, y);\n                    cancelAnimationFrame(requestID);\n                    // Remove listeners\n                    removeListeners();\n                    // Remove animation from the active animations coordinator\n                    activeAnimations.remove(elementToScroll.element, false);\n                    // Resolve promise with a boolean hasScrolledToPosition set to true\n                    resolve(true);\n                }\n            };\n            // Start animating scroll\n            requestID = requestAnimationFrame(step);\n        });\n    });\n}\nexport default animateScrollTo;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}