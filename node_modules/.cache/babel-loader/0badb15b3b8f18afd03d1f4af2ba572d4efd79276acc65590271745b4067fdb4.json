{"ast":null,"code":"import { JsonRequestError, createPlugin } from '@fullcalendar/core/index.js';\nimport { requestJson, addDays, identity } from '@fullcalendar/core/internal.js';\n\n// TODO: expose somehow\nconst API_BASE = 'https://www.googleapis.com/calendar/v3/calendars';\nconst eventSourceDef = {\n  parseMeta(refined) {\n    let {\n      googleCalendarId\n    } = refined;\n    if (!googleCalendarId && refined.url) {\n      googleCalendarId = parseGoogleCalendarId(refined.url);\n    }\n    if (googleCalendarId) {\n      return {\n        googleCalendarId,\n        googleCalendarApiKey: refined.googleCalendarApiKey,\n        googleCalendarApiBase: refined.googleCalendarApiBase,\n        extraParams: refined.extraParams\n      };\n    }\n    return null;\n  },\n  fetch(arg, successCallback, errorCallback) {\n    let {\n      dateEnv,\n      options\n    } = arg.context;\n    let meta = arg.eventSource.meta;\n    let apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey;\n    if (!apiKey) {\n      errorCallback(new Error('Specify a googleCalendarApiKey. See https://fullcalendar.io/docs/google-calendar'));\n    } else {\n      let url = buildUrl(meta);\n      // TODO: make DRY with json-feed-event-source\n      let {\n        extraParams\n      } = meta;\n      let extraParamsObj = typeof extraParams === 'function' ? extraParams() : extraParams;\n      let requestParams = buildRequestParams(arg.range, apiKey, extraParamsObj, dateEnv);\n      return requestJson('GET', url, requestParams).then(_ref => {\n        let [body, response] = _ref;\n        if (body.error) {\n          errorCallback(new JsonRequestError('Google Calendar API: ' + body.error.message, response));\n        } else {\n          successCallback({\n            rawEvents: gcalItemsToRawEventDefs(body.items, requestParams.timeZone),\n            response\n          });\n        }\n      }, errorCallback);\n    }\n  }\n};\nfunction parseGoogleCalendarId(url) {\n  let match;\n  // detect if the ID was specified as a single string.\n  // will match calendars like \"asdf1234@calendar.google.com\" in addition to person email calendars.\n  if (/^[^/]+@([^/.]+\\.)*(google|googlemail|gmail)\\.com$/.test(url)) {\n    return url;\n  }\n  if ((match = /^https:\\/\\/www.googleapis.com\\/calendar\\/v3\\/calendars\\/([^/]*)/.exec(url)) || (match = /^https?:\\/\\/www.google.com\\/calendar\\/feeds\\/([^/]*)/.exec(url))) {\n    return decodeURIComponent(match[1]);\n  }\n  return null;\n}\nfunction buildUrl(meta) {\n  let apiBase = meta.googleCalendarApiBase;\n  if (!apiBase) {\n    apiBase = API_BASE;\n  }\n  return apiBase + '/' + encodeURIComponent(meta.googleCalendarId) + '/events';\n}\nfunction buildRequestParams(range, apiKey, extraParams, dateEnv) {\n  let params;\n  let startStr;\n  let endStr;\n  if (dateEnv.canComputeOffset) {\n    // strings will naturally have offsets, which GCal needs\n    startStr = dateEnv.formatIso(range.start);\n    endStr = dateEnv.formatIso(range.end);\n  } else {\n    // when timezone isn't known, we don't know what the UTC offset should be, so ask for +/- 1 day\n    // from the UTC day-start to guarantee we're getting all the events\n    // (start/end will be UTC-coerced dates, so toISOString is okay)\n    startStr = addDays(range.start, -1).toISOString();\n    endStr = addDays(range.end, 1).toISOString();\n  }\n  params = Object.assign(Object.assign({}, extraParams || {}), {\n    key: apiKey,\n    timeMin: startStr,\n    timeMax: endStr,\n    singleEvents: true,\n    maxResults: 9999\n  });\n  if (dateEnv.timeZone !== 'local') {\n    params.timeZone = dateEnv.timeZone;\n  }\n  return params;\n}\nfunction gcalItemsToRawEventDefs(items, gcalTimezone) {\n  return items.map(item => gcalItemToRawEventDef(item, gcalTimezone));\n}\nfunction gcalItemToRawEventDef(item, gcalTimezone) {\n  let url = item.htmlLink || null;\n  // make the URLs for each event show times in the correct timezone\n  if (url && gcalTimezone) {\n    url = injectQsComponent(url, 'ctz=' + gcalTimezone);\n  }\n  return {\n    id: item.id,\n    title: item.summary,\n    start: item.start.dateTime || item.start.date,\n    end: item.end.dateTime || item.end.date,\n    url,\n    location: item.location,\n    description: item.description,\n    attachments: item.attachments || [],\n    extendedProps: (item.extendedProperties || {}).shared || {}\n  };\n}\n// Injects a string like \"arg=value\" into the querystring of a URL\n// TODO: move to a general util file?\nfunction injectQsComponent(url, component) {\n  // inject it after the querystring but before the fragment\n  return url.replace(/(\\?.*?)?(#|$)/, (whole, qs, hash) => (qs ? qs + '&' : '?') + component + hash);\n}\nconst OPTION_REFINERS = {\n  googleCalendarApiKey: String\n};\nconst EVENT_SOURCE_REFINERS = {\n  googleCalendarApiKey: String,\n  googleCalendarId: String,\n  googleCalendarApiBase: String,\n  extraParams: identity\n};\nvar index = createPlugin({\n  name: '@fullcalendar/google-calendar',\n  eventSourceDefs: [eventSourceDef],\n  optionRefiners: OPTION_REFINERS,\n  eventSourceRefiners: EVENT_SOURCE_REFINERS\n});\nexport { index as default };","map":{"version":3,"names":["JsonRequestError","createPlugin","requestJson","addDays","identity","API_BASE","eventSourceDef","parseMeta","refined","googleCalendarId","url","parseGoogleCalendarId","googleCalendarApiKey","googleCalendarApiBase","extraParams","fetch","arg","successCallback","errorCallback","dateEnv","options","context","meta","eventSource","apiKey","Error","buildUrl","extraParamsObj","requestParams","buildRequestParams","range","then","_ref","body","response","error","message","rawEvents","gcalItemsToRawEventDefs","items","timeZone","match","test","exec","decodeURIComponent","apiBase","encodeURIComponent","params","startStr","endStr","canComputeOffset","formatIso","start","end","toISOString","Object","assign","key","timeMin","timeMax","singleEvents","maxResults","gcalTimezone","map","item","gcalItemToRawEventDef","htmlLink","injectQsComponent","id","title","summary","dateTime","date","location","description","attachments","extendedProps","extendedProperties","shared","component","replace","whole","qs","hash","OPTION_REFINERS","String","EVENT_SOURCE_REFINERS","index","name","eventSourceDefs","optionRefiners","eventSourceRefiners","default"],"sources":["/Users/maxhsu/Desktop/CenterCentre/React_FC_win_calendar/node_modules/@fullcalendar/google-calendar/index.js"],"sourcesContent":["import { JsonRequestError, createPlugin } from '@fullcalendar/core/index.js';\nimport { requestJson, addDays, identity } from '@fullcalendar/core/internal.js';\n\n// TODO: expose somehow\nconst API_BASE = 'https://www.googleapis.com/calendar/v3/calendars';\nconst eventSourceDef = {\n    parseMeta(refined) {\n        let { googleCalendarId } = refined;\n        if (!googleCalendarId && refined.url) {\n            googleCalendarId = parseGoogleCalendarId(refined.url);\n        }\n        if (googleCalendarId) {\n            return {\n                googleCalendarId,\n                googleCalendarApiKey: refined.googleCalendarApiKey,\n                googleCalendarApiBase: refined.googleCalendarApiBase,\n                extraParams: refined.extraParams,\n            };\n        }\n        return null;\n    },\n    fetch(arg, successCallback, errorCallback) {\n        let { dateEnv, options } = arg.context;\n        let meta = arg.eventSource.meta;\n        let apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey;\n        if (!apiKey) {\n            errorCallback(new Error('Specify a googleCalendarApiKey. See https://fullcalendar.io/docs/google-calendar'));\n        }\n        else {\n            let url = buildUrl(meta);\n            // TODO: make DRY with json-feed-event-source\n            let { extraParams } = meta;\n            let extraParamsObj = typeof extraParams === 'function' ? extraParams() : extraParams;\n            let requestParams = buildRequestParams(arg.range, apiKey, extraParamsObj, dateEnv);\n            return requestJson('GET', url, requestParams).then(([body, response]) => {\n                if (body.error) {\n                    errorCallback(new JsonRequestError('Google Calendar API: ' + body.error.message, response));\n                }\n                else {\n                    successCallback({\n                        rawEvents: gcalItemsToRawEventDefs(body.items, requestParams.timeZone),\n                        response,\n                    });\n                }\n            }, errorCallback);\n        }\n    },\n};\nfunction parseGoogleCalendarId(url) {\n    let match;\n    // detect if the ID was specified as a single string.\n    // will match calendars like \"asdf1234@calendar.google.com\" in addition to person email calendars.\n    if (/^[^/]+@([^/.]+\\.)*(google|googlemail|gmail)\\.com$/.test(url)) {\n        return url;\n    }\n    if ((match = /^https:\\/\\/www.googleapis.com\\/calendar\\/v3\\/calendars\\/([^/]*)/.exec(url)) ||\n        (match = /^https?:\\/\\/www.google.com\\/calendar\\/feeds\\/([^/]*)/.exec(url))) {\n        return decodeURIComponent(match[1]);\n    }\n    return null;\n}\nfunction buildUrl(meta) {\n    let apiBase = meta.googleCalendarApiBase;\n    if (!apiBase) {\n        apiBase = API_BASE;\n    }\n    return apiBase + '/' + encodeURIComponent(meta.googleCalendarId) + '/events';\n}\nfunction buildRequestParams(range, apiKey, extraParams, dateEnv) {\n    let params;\n    let startStr;\n    let endStr;\n    if (dateEnv.canComputeOffset) {\n        // strings will naturally have offsets, which GCal needs\n        startStr = dateEnv.formatIso(range.start);\n        endStr = dateEnv.formatIso(range.end);\n    }\n    else {\n        // when timezone isn't known, we don't know what the UTC offset should be, so ask for +/- 1 day\n        // from the UTC day-start to guarantee we're getting all the events\n        // (start/end will be UTC-coerced dates, so toISOString is okay)\n        startStr = addDays(range.start, -1).toISOString();\n        endStr = addDays(range.end, 1).toISOString();\n    }\n    params = Object.assign(Object.assign({}, (extraParams || {})), { key: apiKey, timeMin: startStr, timeMax: endStr, singleEvents: true, maxResults: 9999 });\n    if (dateEnv.timeZone !== 'local') {\n        params.timeZone = dateEnv.timeZone;\n    }\n    return params;\n}\nfunction gcalItemsToRawEventDefs(items, gcalTimezone) {\n    return items.map((item) => gcalItemToRawEventDef(item, gcalTimezone));\n}\nfunction gcalItemToRawEventDef(item, gcalTimezone) {\n    let url = item.htmlLink || null;\n    // make the URLs for each event show times in the correct timezone\n    if (url && gcalTimezone) {\n        url = injectQsComponent(url, 'ctz=' + gcalTimezone);\n    }\n    return {\n        id: item.id,\n        title: item.summary,\n        start: item.start.dateTime || item.start.date,\n        end: item.end.dateTime || item.end.date,\n        url,\n        location: item.location,\n        description: item.description,\n        attachments: item.attachments || [],\n        extendedProps: (item.extendedProperties || {}).shared || {},\n    };\n}\n// Injects a string like \"arg=value\" into the querystring of a URL\n// TODO: move to a general util file?\nfunction injectQsComponent(url, component) {\n    // inject it after the querystring but before the fragment\n    return url.replace(/(\\?.*?)?(#|$)/, (whole, qs, hash) => (qs ? qs + '&' : '?') + component + hash);\n}\n\nconst OPTION_REFINERS = {\n    googleCalendarApiKey: String,\n};\n\nconst EVENT_SOURCE_REFINERS = {\n    googleCalendarApiKey: String,\n    googleCalendarId: String,\n    googleCalendarApiBase: String,\n    extraParams: identity,\n};\n\nvar index = createPlugin({\n    name: '@fullcalendar/google-calendar',\n    eventSourceDefs: [eventSourceDef],\n    optionRefiners: OPTION_REFINERS,\n    eventSourceRefiners: EVENT_SOURCE_REFINERS,\n});\n\nexport { index as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}